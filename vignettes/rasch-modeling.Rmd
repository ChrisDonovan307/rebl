---
title: "Rasch Modeling"
output: 
  rmarkdown::html_vignette:
    css: styles.css
    toc: true
    toc_depth: 2
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Rasch Modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> **NOTE:** Example df is small and simulated, which causes non-convergence errors in some models.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

Something about REBL and PEBs and Rasch models.

Install and load the `rebl` package and friends:

```{r warning = FALSE, output = FALSE}
print(getwd())
library(rebl)
pacman::p_load(
  dplyr, 
  ggplot2,
  ltm,
  eRm
)
```

## Recoding

Take a look at some randomly generated data as an example:

```{r}
head(raw_example[, 1:6])
```

We have a `respondent_id` column and 24 REBL items in the data frame.

It will be mighty convenient if we had a character vector of our REBL items. If you already have this, grand. Otherwise, let's tell `rebl` what our items are. We can do this with a regex pattern. Here, we are just identifying any column that does not start with "res".

```{r}
rebl_items <- id_rebl_items(
  df = raw_example, 
  pattern = '^(?!res).*', 
  perl = TRUE
)
print(rebl_items[1:6])
```

If your items start with "rebl", the regex pattern would be `^rebl*`.

Next, in the event the data for our REBL items are in a yes/no format, we will convert them to 1/0:

```{r}
df <- recode_rebl(
  df = raw_example, 
  rebl_items = rebl_items
)
head(raw_example[, 1:6])
```

Now we recode our reverse-coded REBL items. These are the items where no/0 is the pro-environmental behavior. We start by making a vector of these items with a regex pattern. We use the example here of items that start with "food". (This is silly and confusing though - change this). Then we recode those items.

```{r}
reversed_items <- id_reversed_rebl_items(rebl_items, '^food')
head(reversed_items)
```

Reverse code our new vector of items:

```{r}
df <- reverse_code_rebl_items(df, reversed_items)
head(df[,1:6])
```

## Rasch Models

### CML

Now we're ready to run the Rasch model and get REBL scores. The Rasch model for dichotomous items in the `eRm` package [@mair2007] estimates the probability $P$ of a person $v$ to endorse an item $i$ to be:

$$ 
P(X_{vi}=1)=\frac{exp(\theta_v-\beta_i)}{1+exp(\theta_v-\beta_i)},
$$

where $\theta$ is the latent parameter for person ability (REBL score) and $\beta$ is the latent parameter for item difficulty.

To calculate $\theta$ we just give the function a data frame, the name of the column with the respondent id, and the vector of REBL items:

```{r}
model_cml <- get_rasch_model(
  df = df, 
  id = 'respondent_id', 
  rebl_items = rebl_items,
  type = 'cml'
)
```

Here, the coefficients represent the item difficulty parameters. Note that the discrimination of every item is set to 1.

TODO: Interpretation

### MML

We can also run a set of Marginal Maximum Likelihood (MML) models using the `ltm` package [@rizopoulos2006]. Parameters are estimated by maximizing the log-likelihoods of the observed data. The model is implemented in `ltm` by parameterizing the $m$th sample unit as:

$$
\ell_{m} (\theta)=\log\int p(x_{m}|z_{m};\theta)p(z_{m})dz_{m},
$$

a function of observed response vectors $x_m$, the rank of the respondent in latent trait values $z_m$, and the distribution of person abilities $dz_m$.

First we try a constrained Rasch model, where item discrimination is constrained to all equal 1:

```{r}
model_con <- get_rasch_model(
  df = df, 
  id = 'respondent_id', 
  rebl_items = rebl_items,
  type = 'mml_con'
)
summary(model_con)
```

TODO: Interpretation

We can also run the MML unconstrained, where item discrimination is set to be equal but can vary from one:

```{r}
model_uncon <- get_rasch_model(
  df = df, 
  id = 'respondent_id', 
  rebl_items = rebl_items,
  type = 'mml_uncon'
)
summary(model_uncon)
```

Or a two parameter logistic model that estimates both item difficulty and discrimination:

```{r}
model_2pl <- get_rasch_model(
  df = df, 
  id = 'respondent_id', 
  rebl_items = rebl_items,
  type = 'mml_2pl'
)
summary(model_2pl)
```

Finally, we can use the three parameter logistic model that also estimates a latent variable for guessing:

```{r}
model_tpm <- get_rasch_model(
  df = df, 
  id = 'respondent_id', 
  rebl_items = rebl_items,
  type = 'mml_tpm'
)
summary(model_tpm)
```

## References
